# 带参数的宏定义出现的问题 
    在带参数的宏定义的使用中，极易引起误解。例如我们需要做个宏替换能求任何数的平方，这就需要使用参数，以便在程序中用实际参数来替换宏定义中的参数。一般学生容易写成如下形式： 
    #define area(x) x*x 
    这在使用中是很容易出现问题的，看如下的程序 
    void main() 
    { 
        int y=area(2+2); 
        printf(“%d”,y); 
     } 
    按理说给的参数是2+2，所得的结果应该为4*4=16，但是错了，因为该程序的实际结果为8，仍然是没能遵循纯粹的简单替换的规则，又是先计算再替换 了，在这道程序里，2+2即为area宏中的参数，应该由它来替换宏定义中的x，即替换成2+2*2+2=8了。那如果遵循(1)中的解决办法，把2+2 括起来，即把宏体中的x括起来，是否可以呢？#define area(x) (x)*(x)，对于area(2+2)，替换为(2+2)*(2+2)=16，可以解决，但是对于area(2+2)/area(2+2)又会怎么样 呢，有的学生一看到这道题马上给出结果，因为分子分母一样，又错了，还是忘了遵循先替换再计算的规则了，这道题替换后会变为 (2+2)*(2+2)/(2+2)*(2+2)即4*4/4*4按照乘除运算规则，结果为16/4*4=4*4=16，那应该怎么呢？解决方法是在整个 宏体上再加一个括号，即#define area(x) ((x)*(x))，不要觉得这没必要，没有它，是不行的。 
    要想能够真正使用好宏定义，那么在读别人的程序时，一定要记住先将程序中对宏的使用全部替换成它所代表的字符串，不要自作主张地添加任何其他符号，完全展 开后再进行相应的计算，就不会写错运行结果。如果是自己编程使用宏替换，则在使用简单宏定义时，当字符串中不只一个符号时，加上括号表现出优先级，如果是 带参数的宏定义，则要给宏体中的每个参数加上括号，并在整个宏体上再加一个括号。看到这里，不禁要问，用宏定义这么麻烦，这么容易出错，可不可以摒弃它， 那让我们来看一下在C语言中用宏定义的好处吧。

# C与C++之间的相互调用； extern "C"
	作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：
	void foo(int x, int y);
	该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制）。_foo_int_int这样的名字包含了函数名、参数数量及类型信息，C++就是靠这种机制来实现函数重载的。
	链接阶段在.obj对象中通过_foo_int_int等这样的唯一标识符查找函数。
	因为编译阶段同一函数经过C和C++编译器产生的唯一标识符不同，要想相互调用，必须产生相同的接口。

	1、C++调用C：
	/* C库 fun.h */
	#ifndef CFUN_H
	#define CFUN_H
	void cFun();
	#endif
	/* c库 fun.c */
	#include "cFun.h"
	void cFun(){
		//...
	}
	/* c++ cppFun.cpp调用c 
	   在这个文件中，Fun.h头文件内容全部采用c方式编译、链接
	*/
	extern "C"{
		#include "cFun.h"
	}
	void cppFun(){
		cFun();
	}
	/* c++ cppFun1.cpp调用c 
	   在这个文件中，将cFun函数采用C方式编译、链接，在连接阶段该文件可以找到与cFun对应的函数
	*/
	extern "C"{
		extern void cFun();
	}
	void cppFun1(){
		cFun();
	}

	2、C调用C++
	/* C++库 cppFun.h */
	#ifndef CPPFUN_H
	#define CPPFUN_H
	/* c调用c++，在c++头文件中被调用的c++函数的函数头加extern "c", 采用c方式编译
	   因为c++函数采用c方式编译，链接阶段可以直接找到对应的函数
	*/
	extern "C" void cppFun();
	#endif
	/* C++库 cppFun.cpp */
	#include "cppFun.h"
	void cppFun(){
		//...
	}
	/* c cFun.c调用C++ */
	extern void cppFun();
	void cFun(){
		cppFun();
	}
	
